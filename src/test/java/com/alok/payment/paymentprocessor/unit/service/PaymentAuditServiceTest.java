/**
 * Generated by GitHub Copilot Agent
 * Issue: #generate-tests-payment-audit-logging
 * Date: 2025-12-15
 */
package com.alok.payment.paymentprocessor.unit.service;

import com.alok.payment.paymentprocessor.dto.FraudCheckResponse;
import com.alok.payment.paymentprocessor.model.Payment;
import com.alok.payment.paymentprocessor.model.PaymentAudit;
import com.alok.payment.paymentprocessor.model.PaymentStatus;
import com.alok.payment.paymentprocessor.model.PaymentType;
import com.alok.payment.paymentprocessor.repository.PaymentAuditRepository;
import com.alok.payment.paymentprocessor.service.PaymentAuditService;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
@DisplayName("PaymentAuditService Unit Tests")
class PaymentAuditServiceTest {

    @Mock
    private PaymentAuditRepository auditRepository;

    @InjectMocks
    private PaymentAuditService paymentAuditService;

    private Payment payment;
    private FraudCheckResponse fraudCheckResponse;
    private LocalDateTime processingStartTime;
    private PaymentAudit savedAudit;

    @BeforeEach
    void setUp() {
        // Create a sample payment
        payment = new Payment();
        payment.setId(1L);
        payment.setTransactionId("TXN-001");
        payment.setFromAccount("ACC001");
        payment.setToAccount("ACC002");
        payment.setAmount(new BigDecimal("1000.00"));
        payment.setCurrency("USD");
        payment.setPaymentType(PaymentType.DOMESTIC_TRANSFER);
        payment.setStatus(PaymentStatus.COMPLETED);
        payment.setDescription("Test payment");

        // Create a sample fraud check response
        fraudCheckResponse = new FraudCheckResponse();
        fraudCheckResponse.setTransactionId("TXN-001");
        fraudCheckResponse.setFraudulent(false);
        fraudCheckResponse.setReason("Low risk");
        fraudCheckResponse.setRiskScore(0.2);

        processingStartTime = LocalDateTime.now().minusSeconds(5);

        // Create a sample saved audit
        savedAudit = new PaymentAudit();
        savedAudit.setId(1L);
        savedAudit.setTransactionId("TXN-001");
        savedAudit.setFinalStatus(PaymentStatus.COMPLETED);
    }

    @Test
    @DisplayName("Should create audit record successfully with all details")
    void testAuditPaymentSuccess() {
        when(auditRepository.save(any(PaymentAudit.class))).thenReturn(savedAudit);

        PaymentAudit result = paymentAuditService.auditPayment(
            payment, 
            fraudCheckResponse, 
            true, 
            true, 
            true, 
            processingStartTime
        );

        assertNotNull(result);
        assertEquals(savedAudit.getId(), result.getId());
        
        ArgumentCaptor<PaymentAudit> auditCaptor = ArgumentCaptor.forClass(PaymentAudit.class);
        verify(auditRepository, times(1)).save(auditCaptor.capture());
        
        PaymentAudit capturedAudit = auditCaptor.getValue();
        assertEquals("TXN-001", capturedAudit.getTransactionId());
        assertEquals("ACC001", capturedAudit.getFromAccount());
        assertEquals("ACC002", capturedAudit.getToAccount());
        assertEquals(new BigDecimal("1000.00"), capturedAudit.getAmount());
        assertEquals("USD", capturedAudit.getCurrency());
        assertEquals(PaymentType.DOMESTIC_TRANSFER, capturedAudit.getPaymentType());
        assertEquals("Test payment", capturedAudit.getDescription());
        assertTrue(capturedAudit.getFraudCheckPassed());
        assertEquals("Low risk", capturedAudit.getFraudReason());
        assertEquals("0.2", capturedAudit.getFraudRiskScore());
        assertTrue(capturedAudit.getSourceAccountValid());
        assertTrue(capturedAudit.getDestinationAccountValid());
        assertTrue(capturedAudit.getSufficientBalance());
        assertEquals(PaymentStatus.COMPLETED, capturedAudit.getFinalStatus());
        assertNotNull(capturedAudit.getProcessingTimeMs());
        assertTrue(capturedAudit.getProcessingTimeMs() > 0);
    }

    @Test
    @DisplayName("Should throw NullPointerException when payment is null")
    void testAuditPaymentWithNullPayment() {
        assertThrows(NullPointerException.class, () -> {
            paymentAuditService.auditPayment(
                null, 
                fraudCheckResponse, 
                true, 
                true, 
                true, 
                processingStartTime
            );
        });
        
        verify(auditRepository, never()).save(any(PaymentAudit.class));
    }

    @Test
    @DisplayName("Should throw IllegalArgumentException when transaction ID is null")
    void testAuditPaymentWithNullTransactionId() {
        payment.setTransactionId(null);
        
        assertThrows(IllegalArgumentException.class, () -> {
            paymentAuditService.auditPayment(
                payment, 
                fraudCheckResponse, 
                true, 
                true, 
                true, 
                processingStartTime
            );
        });
        
        verify(auditRepository, never()).save(any(PaymentAudit.class));
    }

    @Test
    @DisplayName("Should handle null fraud check response")
    void testAuditPaymentWithNullFraudResponse() {
        when(auditRepository.save(any(PaymentAudit.class))).thenReturn(savedAudit);

        PaymentAudit result = paymentAuditService.auditPayment(
            payment, 
            null, 
            true, 
            true, 
            true, 
            processingStartTime
        );

        assertNotNull(result);
        
        ArgumentCaptor<PaymentAudit> auditCaptor = ArgumentCaptor.forClass(PaymentAudit.class);
        verify(auditRepository, times(1)).save(auditCaptor.capture());
        
        PaymentAudit capturedAudit = auditCaptor.getValue();
        assertNull(capturedAudit.getFraudCheckPassed());
        assertEquals("Fraud check not performed", capturedAudit.getFraudReason());
    }

    @Test
    @DisplayName("Should create audit for fraudulent payment")
    void testAuditPaymentWithFraud() {
        fraudCheckResponse.setFraudulent(true);
        fraudCheckResponse.setReason("High risk transaction");
        fraudCheckResponse.setRiskScore(0.95);
        payment.setStatus(PaymentStatus.FRAUD_CHECK_FAILED);
        payment.setFailureReason("Fraud detected");
        
        when(auditRepository.save(any(PaymentAudit.class))).thenReturn(savedAudit);

        PaymentAudit result = paymentAuditService.auditPayment(
            payment, 
            fraudCheckResponse, 
            true, 
            true, 
            false, 
            processingStartTime
        );

        assertNotNull(result);
        
        ArgumentCaptor<PaymentAudit> auditCaptor = ArgumentCaptor.forClass(PaymentAudit.class);
        verify(auditRepository, times(1)).save(auditCaptor.capture());
        
        PaymentAudit capturedAudit = auditCaptor.getValue();
        assertFalse(capturedAudit.getFraudCheckPassed());
        assertEquals("High risk transaction", capturedAudit.getFraudReason());
        assertEquals("0.95", capturedAudit.getFraudRiskScore());
        assertEquals(PaymentStatus.FRAUD_CHECK_FAILED, capturedAudit.getFinalStatus());
        assertEquals("Fraud detected", capturedAudit.getFailureReason());
    }

    @Test
    @DisplayName("Should handle null processing start time")
    void testAuditPaymentWithNullProcessingStartTime() {
        when(auditRepository.save(any(PaymentAudit.class))).thenReturn(savedAudit);

        PaymentAudit result = paymentAuditService.auditPayment(
            payment, 
            fraudCheckResponse, 
            true, 
            true, 
            true, 
            null
        );

        assertNotNull(result);
        
        ArgumentCaptor<PaymentAudit> auditCaptor = ArgumentCaptor.forClass(PaymentAudit.class);
        verify(auditRepository, times(1)).save(auditCaptor.capture());
        
        PaymentAudit capturedAudit = auditCaptor.getValue();
        assertNull(capturedAudit.getProcessingTimeMs());
    }

    @Test
    @DisplayName("Should create audit for failed payment")
    void testAuditFailedPayment() {
        payment.setStatus(PaymentStatus.INSUFFICIENT_BALANCE);
        payment.setFailureReason("Insufficient balance");
        
        when(auditRepository.save(any(PaymentAudit.class))).thenReturn(savedAudit);

        PaymentAudit result = paymentAuditService.auditFailedPayment(
            payment, 
            true, 
            true, 
            processingStartTime
        );

        assertNotNull(result);
        
        ArgumentCaptor<PaymentAudit> auditCaptor = ArgumentCaptor.forClass(PaymentAudit.class);
        verify(auditRepository, times(1)).save(auditCaptor.capture());
        
        PaymentAudit capturedAudit = auditCaptor.getValue();
        assertEquals("TXN-001", capturedAudit.getTransactionId());
        assertEquals(PaymentStatus.INSUFFICIENT_BALANCE, capturedAudit.getFinalStatus());
        assertEquals("Insufficient balance", capturedAudit.getFailureReason());
        assertTrue(capturedAudit.getSourceAccountValid());
        assertTrue(capturedAudit.getDestinationAccountValid());
        assertFalse(capturedAudit.getSufficientBalance());
        assertNotNull(capturedAudit.getProcessingTimeMs());
    }

    @Test
    @DisplayName("Should create audit for failed payment with null processing time")
    void testAuditFailedPaymentWithNullProcessingTime() {
        payment.setStatus(PaymentStatus.ACCOUNT_VALIDATION_FAILED);
        
        when(auditRepository.save(any(PaymentAudit.class))).thenReturn(savedAudit);

        PaymentAudit result = paymentAuditService.auditFailedPayment(
            payment, 
            false, 
            false, 
            null
        );

        assertNotNull(result);
        
        ArgumentCaptor<PaymentAudit> auditCaptor = ArgumentCaptor.forClass(PaymentAudit.class);
        verify(auditRepository, times(1)).save(auditCaptor.capture());
        
        PaymentAudit capturedAudit = auditCaptor.getValue();
        assertNull(capturedAudit.getProcessingTimeMs());
        assertFalse(capturedAudit.getSourceAccountValid());
        assertFalse(capturedAudit.getDestinationAccountValid());
    }

    @Test
    @DisplayName("Should retrieve audit by transaction ID")
    void testGetAuditByTransactionId() {
        when(auditRepository.findByTransactionId("TXN-001")).thenReturn(Optional.of(savedAudit));

        Optional<PaymentAudit> result = paymentAuditService.getAuditByTransactionId("TXN-001");

        assertTrue(result.isPresent());
        assertEquals(savedAudit.getId(), result.get().getId());
        verify(auditRepository, times(1)).findByTransactionId("TXN-001");
    }

    @Test
    @DisplayName("Should return empty when audit not found by transaction ID")
    void testGetAuditByTransactionIdNotFound() {
        when(auditRepository.findByTransactionId("INVALID")).thenReturn(Optional.empty());

        Optional<PaymentAudit> result = paymentAuditService.getAuditByTransactionId("INVALID");

        assertFalse(result.isPresent());
        verify(auditRepository, times(1)).findByTransactionId("INVALID");
    }

    @Test
    @DisplayName("Should throw IllegalArgumentException when transaction ID is null")
    void testGetAuditByTransactionIdWithNull() {
        assertThrows(IllegalArgumentException.class, () -> {
            paymentAuditService.getAuditByTransactionId(null);
        });
        
        verify(auditRepository, never()).findByTransactionId(any());
    }

    @Test
    @DisplayName("Should throw IllegalArgumentException when transaction ID is empty")
    void testGetAuditByTransactionIdWithEmpty() {
        assertThrows(IllegalArgumentException.class, () -> {
            paymentAuditService.getAuditByTransactionId("  ");
        });
        
        verify(auditRepository, never()).findByTransactionId(any());
    }

    @Test
    @DisplayName("Should retrieve audits by account number")
    void testGetAuditsByAccount() {
        PaymentAudit audit1 = new PaymentAudit();
        audit1.setId(1L);
        audit1.setFromAccount("ACC001");
        
        PaymentAudit audit2 = new PaymentAudit();
        audit2.setId(2L);
        audit2.setToAccount("ACC001");
        
        // Use mutable lists to support addAll operation in service
        when(auditRepository.findByFromAccount("ACC001")).thenReturn(new java.util.ArrayList<>(List.of(audit1)));
        when(auditRepository.findByToAccount("ACC001")).thenReturn(new java.util.ArrayList<>(List.of(audit2)));

        List<PaymentAudit> result = paymentAuditService.getAuditsByAccount("ACC001");

        assertNotNull(result);
        assertEquals(2, result.size());
        verify(auditRepository, times(1)).findByFromAccount("ACC001");
        verify(auditRepository, times(1)).findByToAccount("ACC001");
    }

    @Test
    @DisplayName("Should throw IllegalArgumentException when account number is null")
    void testGetAuditsByAccountWithNull() {
        assertThrows(IllegalArgumentException.class, () -> {
            paymentAuditService.getAuditsByAccount(null);
        });
        
        verify(auditRepository, never()).findByFromAccount(any());
        verify(auditRepository, never()).findByToAccount(any());
    }

    @Test
    @DisplayName("Should throw IllegalArgumentException when account number is empty")
    void testGetAuditsByAccountWithEmpty() {
        assertThrows(IllegalArgumentException.class, () -> {
            paymentAuditService.getAuditsByAccount("  ");
        });
        
        verify(auditRepository, never()).findByFromAccount(any());
        verify(auditRepository, never()).findByToAccount(any());
    }

    @Test
    @DisplayName("Should retrieve audits by status")
    void testGetAuditsByStatus() {
        List<PaymentAudit> audits = Arrays.asList(savedAudit);
        when(auditRepository.findByFinalStatus(PaymentStatus.COMPLETED)).thenReturn(audits);

        List<PaymentAudit> result = paymentAuditService.getAuditsByStatus(PaymentStatus.COMPLETED);

        assertNotNull(result);
        assertEquals(1, result.size());
        verify(auditRepository, times(1)).findByFinalStatus(PaymentStatus.COMPLETED);
    }

    @Test
    @DisplayName("Should throw IllegalArgumentException when status is null")
    void testGetAuditsByStatusWithNull() {
        assertThrows(IllegalArgumentException.class, () -> {
            paymentAuditService.getAuditsByStatus(null);
        });
        
        verify(auditRepository, never()).findByFinalStatus(any());
    }

    @Test
    @DisplayName("Should retrieve fraudulent payment audits")
    void testGetFraudulentPaymentAudits() {
        PaymentAudit fraudAudit = new PaymentAudit();
        fraudAudit.setId(1L);
        fraudAudit.setFraudCheckPassed(false);
        
        List<PaymentAudit> audits = Arrays.asList(fraudAudit);
        when(auditRepository.findByFraudCheckPassed(false)).thenReturn(audits);

        List<PaymentAudit> result = paymentAuditService.getFraudulentPaymentAudits();

        assertNotNull(result);
        assertEquals(1, result.size());
        verify(auditRepository, times(1)).findByFraudCheckPassed(false);
    }

    @Test
    @DisplayName("Should retrieve audits by date range")
    void testGetAuditsByDateRange() {
        LocalDateTime startDate = LocalDateTime.now().minusDays(7);
        LocalDateTime endDate = LocalDateTime.now();
        
        List<PaymentAudit> audits = Arrays.asList(savedAudit);
        when(auditRepository.findByAuditedAtBetween(startDate, endDate)).thenReturn(audits);

        List<PaymentAudit> result = paymentAuditService.getAuditsByDateRange(startDate, endDate);

        assertNotNull(result);
        assertEquals(1, result.size());
        verify(auditRepository, times(1)).findByAuditedAtBetween(startDate, endDate);
    }

    @Test
    @DisplayName("Should throw IllegalArgumentException when start date is null")
    void testGetAuditsByDateRangeWithNullStartDate() {
        LocalDateTime endDate = LocalDateTime.now();
        
        assertThrows(IllegalArgumentException.class, () -> {
            paymentAuditService.getAuditsByDateRange(null, endDate);
        });
        
        verify(auditRepository, never()).findByAuditedAtBetween(any(), any());
    }

    @Test
    @DisplayName("Should throw IllegalArgumentException when end date is null")
    void testGetAuditsByDateRangeWithNullEndDate() {
        LocalDateTime startDate = LocalDateTime.now().minusDays(7);
        
        assertThrows(IllegalArgumentException.class, () -> {
            paymentAuditService.getAuditsByDateRange(startDate, null);
        });
        
        verify(auditRepository, never()).findByAuditedAtBetween(any(), any());
    }

    @Test
    @DisplayName("Should throw IllegalArgumentException when start date is after end date")
    void testGetAuditsByDateRangeWithInvalidRange() {
        LocalDateTime startDate = LocalDateTime.now();
        LocalDateTime endDate = LocalDateTime.now().minusDays(7);
        
        assertThrows(IllegalArgumentException.class, () -> {
            paymentAuditService.getAuditsByDateRange(startDate, endDate);
        });
        
        verify(auditRepository, never()).findByAuditedAtBetween(any(), any());
    }

    @Test
    @DisplayName("Should calculate average processing time")
    void testCalculateAverageProcessingTime() {
        PaymentAudit audit1 = new PaymentAudit();
        audit1.setProcessingTimeMs(1000L);
        
        PaymentAudit audit2 = new PaymentAudit();
        audit2.setProcessingTimeMs(2000L);
        
        List<PaymentAudit> audits = Arrays.asList(audit1, audit2);
        when(auditRepository.findByFinalStatus(PaymentStatus.COMPLETED)).thenReturn(audits);

        Double result = paymentAuditService.calculateAverageProcessingTime();

        assertNotNull(result);
        assertEquals(1500.0, result, 0.01);
        verify(auditRepository, times(1)).findByFinalStatus(PaymentStatus.COMPLETED);
    }

    @Test
    @DisplayName("Should return 0.0 when no successful audits exist")
    void testCalculateAverageProcessingTimeWithNoAudits() {
        when(auditRepository.findByFinalStatus(PaymentStatus.COMPLETED)).thenReturn(Collections.emptyList());

        Double result = paymentAuditService.calculateAverageProcessingTime();

        assertNotNull(result);
        assertEquals(0.0, result, 0.01);
    }

    @Test
    @DisplayName("Should handle audits with null processing time")
    void testCalculateAverageProcessingTimeWithNullValues() {
        PaymentAudit audit1 = new PaymentAudit();
        audit1.setProcessingTimeMs(1000L);
        
        PaymentAudit audit2 = new PaymentAudit();
        audit2.setProcessingTimeMs(null);
        
        PaymentAudit audit3 = new PaymentAudit();
        audit3.setProcessingTimeMs(3000L);
        
        List<PaymentAudit> audits = Arrays.asList(audit1, audit2, audit3);
        when(auditRepository.findByFinalStatus(PaymentStatus.COMPLETED)).thenReturn(audits);

        Double result = paymentAuditService.calculateAverageProcessingTime();

        assertNotNull(result);
        assertEquals(2000.0, result, 0.01);
    }

    @Test
    @DisplayName("Should calculate fraud detection rate")
    void testGetFraudDetectionRate() {
        PaymentAudit audit1 = new PaymentAudit();
        audit1.setFraudCheckPassed(true);
        
        PaymentAudit audit2 = new PaymentAudit();
        audit2.setFraudCheckPassed(false);
        
        PaymentAudit audit3 = new PaymentAudit();
        audit3.setFraudCheckPassed(false);
        
        PaymentAudit audit4 = new PaymentAudit();
        audit4.setFraudCheckPassed(true);
        
        List<PaymentAudit> audits = Arrays.asList(audit1, audit2, audit3, audit4);
        when(auditRepository.findAll()).thenReturn(audits);

        Double result = paymentAuditService.getFraudDetectionRate();

        assertNotNull(result);
        assertEquals(50.0, result, 0.01);
        verify(auditRepository, times(1)).findAll();
    }

    @Test
    @DisplayName("Should return 0.0 fraud rate when no audits exist")
    void testGetFraudDetectionRateWithNoAudits() {
        when(auditRepository.findAll()).thenReturn(Collections.emptyList());

        Double result = paymentAuditService.getFraudDetectionRate();

        assertNotNull(result);
        assertEquals(0.0, result, 0.01);
    }

    @Test
    @DisplayName("Should handle audits with null fraud check passed")
    void testGetFraudDetectionRateWithNullValues() {
        PaymentAudit audit1 = new PaymentAudit();
        audit1.setFraudCheckPassed(true);
        
        PaymentAudit audit2 = new PaymentAudit();
        audit2.setFraudCheckPassed(null);
        
        PaymentAudit audit3 = new PaymentAudit();
        audit3.setFraudCheckPassed(false);
        
        List<PaymentAudit> audits = Arrays.asList(audit1, audit2, audit3);
        when(auditRepository.findAll()).thenReturn(audits);

        Double result = paymentAuditService.getFraudDetectionRate();

        assertNotNull(result);
        assertEquals(33.33, result, 0.01);
    }
}
