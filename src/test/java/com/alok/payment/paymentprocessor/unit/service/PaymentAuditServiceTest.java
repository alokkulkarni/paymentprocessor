/**
 * Generated by GitHub Copilot Agent
 * Issue: #generate-tests-for-payment-audit
 * Date: 2025-12-15
 * DO NOT EDIT: This test was auto-generated. Review and modify as needed.
 */
package com.alok.payment.paymentprocessor.unit.service;

import com.alok.payment.paymentprocessor.model.Payment;
import com.alok.payment.paymentprocessor.model.PaymentAudit;
import com.alok.payment.paymentprocessor.model.PaymentStatus;
import com.alok.payment.paymentprocessor.model.PaymentType;
import com.alok.payment.paymentprocessor.repository.PaymentAuditRepository;
import com.alok.payment.paymentprocessor.service.PaymentAuditService;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
@DisplayName("PaymentAuditService Unit Tests")
class PaymentAuditServiceTest {

    @Mock
    private PaymentAuditRepository auditRepository;

    @InjectMocks
    private PaymentAuditService auditService;

    private Payment testPayment;
    private PaymentAudit savedAudit;

    @BeforeEach
    void setUp() {
        testPayment = new Payment(
            "TXN-TEST-001",
            "ACC001",
            "ACC002",
            new BigDecimal("1000.00"),
            "USD",
            PaymentType.DOMESTIC_TRANSFER,
            "Test payment for audit"
        );
        testPayment.setId(1L);
        testPayment.setStatus(PaymentStatus.PENDING);

        savedAudit = new PaymentAudit();
        savedAudit.setId(1L);
        savedAudit.setTransactionId("TXN-TEST-001");
        savedAudit.setAction("PAYMENT_CREATED");
        savedAudit.setNewStatus(PaymentStatus.PENDING);
        savedAudit.setFromAccount("ACC001");
        savedAudit.setToAccount("ACC002");
        savedAudit.setAmount(new BigDecimal("1000.00"));
        savedAudit.setCurrency("USD");
        savedAudit.setPerformedBy("SYSTEM");
        savedAudit.setDetails("Payment initiated: Test payment for audit");
    }

    @Test
    @DisplayName("Should log payment creation successfully")
    void testLogPaymentCreated() {
        when(auditRepository.save(any(PaymentAudit.class))).thenReturn(savedAudit);

        PaymentAudit result = auditService.logPaymentCreated(testPayment, "SYSTEM");

        assertNotNull(result);
        assertEquals("TXN-TEST-001", result.getTransactionId());
        assertEquals("PAYMENT_CREATED", result.getAction());
        assertEquals(PaymentStatus.PENDING, result.getNewStatus());
        assertNull(result.getOldStatus());
        assertEquals("SYSTEM", result.getPerformedBy());

        ArgumentCaptor<PaymentAudit> auditCaptor = ArgumentCaptor.forClass(PaymentAudit.class);
        verify(auditRepository, times(1)).save(auditCaptor.capture());
        
        PaymentAudit capturedAudit = auditCaptor.getValue();
        assertEquals("PAYMENT_CREATED", capturedAudit.getAction());
        assertEquals("ACC001", capturedAudit.getFromAccount());
        assertEquals("ACC002", capturedAudit.getToAccount());
    }

    @Test
    @DisplayName("Should log status change successfully")
    void testLogStatusChange() {
        testPayment.setStatus(PaymentStatus.PROCESSING);
        savedAudit.setAction("STATUS_CHANGE");
        savedAudit.setOldStatus(PaymentStatus.PENDING);
        savedAudit.setNewStatus(PaymentStatus.PROCESSING);

        when(auditRepository.save(any(PaymentAudit.class))).thenReturn(savedAudit);

        PaymentAudit result = auditService.logStatusChange(testPayment, PaymentStatus.PENDING, "SYSTEM");

        assertNotNull(result);
        assertEquals("STATUS_CHANGE", result.getAction());
        assertEquals(PaymentStatus.PENDING, result.getOldStatus());
        assertEquals(PaymentStatus.PROCESSING, result.getNewStatus());

        verify(auditRepository, times(1)).save(any(PaymentAudit.class));
    }

    @Test
    @DisplayName("Should log payment completion successfully")
    void testLogPaymentCompleted() {
        testPayment.setStatus(PaymentStatus.COMPLETED);
        savedAudit.setAction("PAYMENT_COMPLETED");
        savedAudit.setOldStatus(PaymentStatus.PROCESSING);
        savedAudit.setNewStatus(PaymentStatus.COMPLETED);

        when(auditRepository.save(any(PaymentAudit.class))).thenReturn(savedAudit);

        PaymentAudit result = auditService.logPaymentCompleted(testPayment, "SYSTEM");

        assertNotNull(result);
        assertEquals("PAYMENT_COMPLETED", result.getAction());
        assertEquals(PaymentStatus.COMPLETED, result.getNewStatus());

        ArgumentCaptor<PaymentAudit> auditCaptor = ArgumentCaptor.forClass(PaymentAudit.class);
        verify(auditRepository, times(1)).save(auditCaptor.capture());
        
        PaymentAudit capturedAudit = auditCaptor.getValue();
        assertTrue(capturedAudit.getDetails().contains("completed successfully"));
    }

    @Test
    @DisplayName("Should log payment failure successfully")
    void testLogPaymentFailed() {
        testPayment.setStatus(PaymentStatus.FRAUD_CHECK_FAILED);
        savedAudit.setAction("PAYMENT_FAILED");
        savedAudit.setOldStatus(PaymentStatus.PENDING);
        savedAudit.setNewStatus(PaymentStatus.FRAUD_CHECK_FAILED);
        savedAudit.setDetails("Payment failed: High risk transaction");

        when(auditRepository.save(any(PaymentAudit.class))).thenReturn(savedAudit);

        PaymentAudit result = auditService.logPaymentFailed(
            testPayment, 
            PaymentStatus.PENDING, 
            "High risk transaction", 
            "SYSTEM"
        );

        assertNotNull(result);
        assertEquals("PAYMENT_FAILED", result.getAction());
        assertEquals(PaymentStatus.FRAUD_CHECK_FAILED, result.getNewStatus());
        assertTrue(result.getDetails().contains("High risk transaction"));

        verify(auditRepository, times(1)).save(any(PaymentAudit.class));
    }

    @Test
    @DisplayName("Should retrieve audit trail by transaction ID")
    void testGetAuditTrail() {
        List<PaymentAudit> auditList = new ArrayList<>();
        auditList.add(savedAudit);

        when(auditRepository.findByTransactionId("TXN-TEST-001")).thenReturn(auditList);

        List<PaymentAudit> result = auditService.getAuditTrail("TXN-TEST-001");

        assertNotNull(result);
        assertEquals(1, result.size());
        assertEquals("TXN-TEST-001", result.get(0).getTransactionId());

        verify(auditRepository, times(1)).findByTransactionId("TXN-TEST-001");
    }

    @Test
    @DisplayName("Should retrieve audit records by account")
    void testGetAuditByAccount() {
        List<PaymentAudit> auditList = new ArrayList<>();
        auditList.add(savedAudit);

        when(auditRepository.findByAccount("ACC001")).thenReturn(auditList);

        List<PaymentAudit> result = auditService.getAuditByAccount("ACC001");

        assertNotNull(result);
        assertEquals(1, result.size());
        assertEquals("ACC001", result.get(0).getFromAccount());

        verify(auditRepository, times(1)).findByAccount("ACC001");
    }

    @Test
    @DisplayName("Should retrieve audit records by action")
    void testGetAuditByAction() {
        List<PaymentAudit> auditList = new ArrayList<>();
        auditList.add(savedAudit);

        when(auditRepository.findByAction("PAYMENT_CREATED")).thenReturn(auditList);

        List<PaymentAudit> result = auditService.getAuditByAction("PAYMENT_CREATED");

        assertNotNull(result);
        assertEquals(1, result.size());
        assertEquals("PAYMENT_CREATED", result.get(0).getAction());

        verify(auditRepository, times(1)).findByAction("PAYMENT_CREATED");
    }

    @Test
    @DisplayName("Should retrieve audit records by date range")
    void testGetAuditByDateRange() {
        LocalDateTime startDate = LocalDateTime.now().minusDays(7);
        LocalDateTime endDate = LocalDateTime.now();
        
        List<PaymentAudit> auditList = new ArrayList<>();
        auditList.add(savedAudit);

        when(auditRepository.findByAuditTimestampBetween(startDate, endDate)).thenReturn(auditList);

        List<PaymentAudit> result = auditService.getAuditByDateRange(startDate, endDate);

        assertNotNull(result);
        assertEquals(1, result.size());

        verify(auditRepository, times(1)).findByAuditTimestampBetween(startDate, endDate);
    }

    @Test
    @DisplayName("Should retrieve recent audit records")
    void testGetRecentAudits() {
        List<PaymentAudit> auditList = new ArrayList<>();
        auditList.add(savedAudit);

        when(auditRepository.findRecentAudits(10)).thenReturn(auditList);

        List<PaymentAudit> result = auditService.getRecentAudits(10);

        assertNotNull(result);
        assertEquals(1, result.size());

        verify(auditRepository, times(1)).findRecentAudits(10);
    }

    @Test
    @DisplayName("Should handle empty audit trail")
    void testGetAuditTrailEmpty() {
        when(auditRepository.findByTransactionId("NON-EXISTENT")).thenReturn(new ArrayList<>());

        List<PaymentAudit> result = auditService.getAuditTrail("NON-EXISTENT");

        assertNotNull(result);
        assertTrue(result.isEmpty());

        verify(auditRepository, times(1)).findByTransactionId("NON-EXISTENT");
    }

    @Test
    @DisplayName("Should log audit with correct timestamp")
    void testAuditTimestamp() {
        ArgumentCaptor<PaymentAudit> auditCaptor = ArgumentCaptor.forClass(PaymentAudit.class);
        when(auditRepository.save(any(PaymentAudit.class))).thenReturn(savedAudit);

        auditService.logPaymentCreated(testPayment, "SYSTEM");

        verify(auditRepository).save(auditCaptor.capture());
        PaymentAudit capturedAudit = auditCaptor.getValue();
        
        assertNotNull(capturedAudit.getAuditTimestamp());
        assertTrue(capturedAudit.getAuditTimestamp().isBefore(LocalDateTime.now().plusSeconds(1)));
    }

    @Test
    @DisplayName("Should capture all payment details in audit")
    void testAuditCapturesAllDetails() {
        ArgumentCaptor<PaymentAudit> auditCaptor = ArgumentCaptor.forClass(PaymentAudit.class);
        when(auditRepository.save(any(PaymentAudit.class))).thenReturn(savedAudit);

        auditService.logPaymentCreated(testPayment, "USER123");

        verify(auditRepository).save(auditCaptor.capture());
        PaymentAudit capturedAudit = auditCaptor.getValue();
        
        assertEquals(testPayment.getTransactionId(), capturedAudit.getTransactionId());
        assertEquals(testPayment.getFromAccount(), capturedAudit.getFromAccount());
        assertEquals(testPayment.getToAccount(), capturedAudit.getToAccount());
        assertEquals(testPayment.getAmount(), capturedAudit.getAmount());
        assertEquals(testPayment.getCurrency(), capturedAudit.getCurrency());
        assertEquals("USER123", capturedAudit.getPerformedBy());
    }

    @Test
    @DisplayName("Should log multiple status changes in sequence")
    void testMultipleStatusChanges() {
        when(auditRepository.save(any(PaymentAudit.class))).thenReturn(savedAudit);

        // First status change: PENDING -> PROCESSING
        testPayment.setStatus(PaymentStatus.PROCESSING);
        auditService.logStatusChange(testPayment, PaymentStatus.PENDING, "SYSTEM");

        // Second status change: PROCESSING -> COMPLETED
        testPayment.setStatus(PaymentStatus.COMPLETED);
        auditService.logStatusChange(testPayment, PaymentStatus.PROCESSING, "SYSTEM");

        verify(auditRepository, times(2)).save(any(PaymentAudit.class));
    }

    @Test
    @DisplayName("Should handle different payment types in audit")
    void testDifferentPaymentTypes() {
        when(auditRepository.save(any(PaymentAudit.class))).thenReturn(savedAudit);

        Payment interbankPayment = new Payment(
            "TXN-TEST-002",
            "ACC001",
            "ACC002",
            new BigDecimal("5000.00"),
            "USD",
            PaymentType.INTERBANK_TRANSFER,
            "Interbank transfer test"
        );

        auditService.logPaymentCreated(interbankPayment, "SYSTEM");

        verify(auditRepository, times(1)).save(any(PaymentAudit.class));
    }
}
