/**
 * Generated by GitHub Copilot Agent
 * Issue: #generate-tests-for-payment-audit
 * Date: 2025-12-15
 * NOTE: This test was auto-generated. Please review and modify as needed.
 */
package com.alok.payment.paymentprocessor.bdd;

import com.alok.payment.paymentprocessor.dto.PaymentRequest;
import com.alok.payment.paymentprocessor.dto.PaymentResponse;
import com.alok.payment.paymentprocessor.model.PaymentAudit;
import com.alok.payment.paymentprocessor.model.PaymentStatus;
import com.alok.payment.paymentprocessor.model.PaymentType;
import com.alok.payment.paymentprocessor.repository.PaymentAuditRepository;
import io.cucumber.java.en.And;
import io.cucumber.java.en.Then;
import io.cucumber.java.en.When;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.web.client.TestRestTemplate;
import org.springframework.http.ResponseEntity;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Cucumber step definitions for payment audit logging BDD tests.
 */
public class PaymentAuditSteps {

    @Autowired
    private TestRestTemplate restTemplate;

    @Autowired
    private PaymentAuditRepository auditRepository;

    private ResponseEntity<PaymentResponse> lastPaymentResponse;
    private String lastTransactionId;
    private List<PaymentAudit> lastAuditTrail;
    private List<PaymentAudit> queriedAudits;
    private List<String> allTransactionIds = new ArrayList<>();

    @Then("an audit trail should exist for the payment")
    public void anAuditTrailShouldExistForThePayment() {
        assertNotNull(lastPaymentResponse);
        assertNotNull(lastPaymentResponse.getBody());
        lastTransactionId = lastPaymentResponse.getBody().getTransactionId();
        
        lastAuditTrail = auditRepository.findByTransactionId(lastTransactionId);
        
        assertNotNull(lastAuditTrail);
        assertFalse(lastAuditTrail.isEmpty(), "Audit trail should not be empty");
    }

    @And("the audit trail should contain {string} action")
    public void theAuditTrailShouldContainAction(String action) {
        assertNotNull(lastAuditTrail);
        
        boolean hasAction = lastAuditTrail.stream()
            .anyMatch(audit -> action.equals(audit.getAction()));
        
        assertTrue(hasAction, "Audit trail should contain action: " + action);
    }

    @And("the audit should record {string} as from account")
    public void theAuditShouldRecordAsFromAccount(String fromAccount) {
        assertNotNull(lastAuditTrail);
        
        boolean hasFromAccount = lastAuditTrail.stream()
            .anyMatch(audit -> fromAccount.equals(audit.getFromAccount()));
        
        assertTrue(hasFromAccount, "Audit should record from account: " + fromAccount);
    }

    @And("the audit should record {string} as to account")
    public void theAuditShouldRecordAsToAccount(String toAccount) {
        assertNotNull(lastAuditTrail);
        
        boolean hasToAccount = lastAuditTrail.stream()
            .anyMatch(audit -> toAccount.equals(audit.getToAccount()));
        
        assertTrue(hasToAccount, "Audit should record to account: " + toAccount);
    }

    @And("the audit should record fraud failure reason")
    public void theAuditShouldRecordFraudFailureReason() {
        assertNotNull(lastAuditTrail);
        
        boolean hasFraudFailure = lastAuditTrail.stream()
            .anyMatch(audit -> 
                "PAYMENT_FAILED".equals(audit.getAction()) && 
                audit.getNewStatus() == PaymentStatus.FRAUD_CHECK_FAILED
            );
        
        assertTrue(hasFraudFailure, "Audit should record fraud failure");
    }

    @And("the audit should record insufficient balance failure")
    public void theAuditShouldRecordInsufficientBalanceFailure() {
        assertNotNull(lastAuditTrail);
        
        boolean hasInsufficientBalanceFailure = lastAuditTrail.stream()
            .anyMatch(audit -> audit.getNewStatus() == PaymentStatus.INSUFFICIENT_BALANCE);
        
        assertTrue(hasInsufficientBalanceFailure, "Audit should record insufficient balance failure");
    }

    @And("the status change audit should record old and new status")
    public void theStatusChangeAuditShouldRecordOldAndNewStatus() {
        assertNotNull(lastAuditTrail);
        
        List<PaymentAudit> statusChangeAudits = lastAuditTrail.stream()
            .filter(audit -> "STATUS_CHANGE".equals(audit.getAction()))
            .collect(Collectors.toList());
        
        assertFalse(statusChangeAudits.isEmpty(), "Should have status change audits");
        
        for (PaymentAudit audit : statusChangeAudits) {
            assertNotNull(audit.getOldStatus(), "Old status should not be null");
            assertNotNull(audit.getNewStatus(), "New status should not be null");
        }
    }

    @And("the audit should record amount as {double}")
    public void theAuditShouldRecordAmountAs(double amount) {
        assertNotNull(lastAuditTrail);
        
        BigDecimal expectedAmount = BigDecimal.valueOf(amount);
        boolean hasAmount = lastAuditTrail.stream()
            .anyMatch(audit -> expectedAmount.compareTo(audit.getAmount()) == 0);
        
        assertTrue(hasAmount, "Audit should record amount: " + amount);
    }

    @And("the audit should record currency as {string}")
    public void theAuditShouldRecordCurrencyAs(String currency) {
        assertNotNull(lastAuditTrail);
        
        boolean hasCurrency = lastAuditTrail.stream()
            .anyMatch(audit -> currency.equals(audit.getCurrency()));
        
        assertTrue(hasCurrency, "Audit should record currency: " + currency);
    }

    @And("the audit should record performer as {string}")
    public void theAuditShouldRecordPerformerAs(String performer) {
        assertNotNull(lastAuditTrail);
        
        boolean hasPerformer = lastAuditTrail.stream()
            .anyMatch(audit -> performer.equals(audit.getPerformedBy()));
        
        assertTrue(hasPerformer, "Audit should record performer: " + performer);
    }

    @When("I query audit trail by transaction ID")
    public void iQueryAuditTrailByTransactionID() {
        assertNotNull(lastTransactionId);
        queriedAudits = auditRepository.findByTransactionId(lastTransactionId);
    }

    @Then("I should receive multiple audit records")
    public void iShouldReceiveMultipleAuditRecords() {
        assertNotNull(queriedAudits);
        assertTrue(queriedAudits.size() > 1, "Should receive multiple audit records");
    }

    @And("all audit records should have the same transaction ID")
    public void allAuditRecordsShouldHaveTheSameTransactionID() {
        assertNotNull(queriedAudits);
        
        for (PaymentAudit audit : queriedAudits) {
            assertEquals(lastTransactionId, audit.getTransactionId());
        }
    }

    @When("I query audit records for account {string}")
    public void iQueryAuditRecordsForAccount(String account) {
        queriedAudits = auditRepository.findByAccount(account);
    }

    @Then("I should receive audit records involving {string}")
    public void iShouldReceiveAuditRecordsInvolving(String account) {
        assertNotNull(queriedAudits);
        assertFalse(queriedAudits.isEmpty(), "Should receive audit records for account: " + account);
    }

    @And("all audit records should involve account {string} as from or to account")
    public void allAuditRecordsShouldInvolveAccountAsFromOrToAccount(String account) {
        assertNotNull(queriedAudits);
        
        for (PaymentAudit audit : queriedAudits) {
            assertTrue(
                account.equals(audit.getFromAccount()) || account.equals(audit.getToAccount()),
                "Audit should involve account: " + account
            );
        }
    }

    @When("I query audit records by action {string}")
    public void iQueryAuditRecordsByAction(String action) {
        queriedAudits = auditRepository.findByAction(action);
    }

    @Then("I should receive audit records with action {string}")
    public void iShouldReceiveAuditRecordsWithAction(String action) {
        assertNotNull(queriedAudits);
        assertFalse(queriedAudits.isEmpty(), "Should receive audit records with action: " + action);
        
        for (PaymentAudit audit : queriedAudits) {
            assertEquals(action, audit.getAction());
        }
    }

    @And("all audit records should have valid timestamps")
    public void allAuditRecordsShouldHaveValidTimestamps() {
        assertNotNull(lastAuditTrail);
        
        LocalDateTime now = LocalDateTime.now();
        LocalDateTime oneHourAgo = now.minusHours(1);
        
        for (PaymentAudit audit : lastAuditTrail) {
            assertNotNull(audit.getAuditTimestamp(), "Audit timestamp should not be null");
            assertTrue(audit.getAuditTimestamp().isAfter(oneHourAgo), "Audit timestamp should be recent");
            assertTrue(audit.getAuditTimestamp().isBefore(now.plusMinutes(1)), "Audit timestamp should not be in future");
        }
    }

    @And("audit timestamps should be in chronological order")
    public void auditTimestampsShouldBeInChronologicalOrder() {
        assertNotNull(lastAuditTrail);
        
        if (lastAuditTrail.size() > 1) {
            for (int i = 0; i < lastAuditTrail.size() - 1; i++) {
                LocalDateTime current = lastAuditTrail.get(i).getAuditTimestamp();
                LocalDateTime next = lastAuditTrail.get(i + 1).getAuditTimestamp();
                
                // Timestamps should be in order or equal (for operations happening in same millisecond)
                assertTrue(
                    current.isBefore(next) || current.isEqual(next),
                    "Audit timestamps should be in chronological order"
                );
            }
        }
    }

    @Then("each payment should have its own audit trail")
    public void eachPaymentShouldHaveItsOwnAuditTrail() {
        // Verify each transaction has its own distinct audit records
        for (String txnId : allTransactionIds) {
            List<PaymentAudit> auditTrail = auditRepository.findByTransactionId(txnId);
            assertFalse(auditTrail.isEmpty(), "Each payment should have audit trail");
        }
    }

    @And("the total number of audit records should be at least {int}")
    public void theTotalNumberOfAuditRecordsShouldBeAtLeast(int minCount) {
        int totalAudits = 0;
        for (String txnId : allTransactionIds) {
            List<PaymentAudit> auditTrail = auditRepository.findByTransactionId(txnId);
            totalAudits += auditTrail.size();
        }
        
        assertTrue(totalAudits >= minCount, 
            "Total audit records should be at least " + minCount + " but was " + totalAudits);
    }

    @And("the audit should capture detailed failure reason")
    public void theAuditShouldCaptureDetailedFailureReason() {
        assertNotNull(lastAuditTrail);
        
        List<PaymentAudit> failureAudits = lastAuditTrail.stream()
            .filter(audit -> "PAYMENT_FAILED".equals(audit.getAction()))
            .collect(Collectors.toList());
        
        assertFalse(failureAudits.isEmpty(), "Should have failure audits");
        
        for (PaymentAudit audit : failureAudits) {
            assertNotNull(audit.getDetails(), "Failure audit should have details");
            assertFalse(audit.getDetails().isEmpty(), "Failure details should not be empty");
        }
    }

    @And("the failure reason should contain account validation information")
    public void theFailureReasonShouldContainAccountValidationInformation() {
        assertNotNull(lastAuditTrail);
        
        boolean hasValidationInfo = lastAuditTrail.stream()
            .anyMatch(audit -> 
                audit.getDetails() != null && 
                audit.getDetails().toLowerCase().contains("account")
            );
        
        assertTrue(hasValidationInfo, "Failure reason should contain account validation information");
    }

    @When("I query recent audit records with limit {int}")
    public void iQueryRecentAuditRecordsWithLimit(int limit) {
        queriedAudits = auditRepository.findRecentAudits(limit);
    }

    @Then("I should receive at most {int} audit records")
    public void iShouldReceiveAtMostAuditRecords(int maxCount) {
        assertNotNull(queriedAudits);
        assertTrue(queriedAudits.size() <= maxCount, 
            "Should receive at most " + maxCount + " audit records but got " + queriedAudits.size());
    }

    @And("the audit records should be the most recent ones")
    public void theAuditRecordsShouldBeTheMostRecentOnes() {
        assertNotNull(queriedAudits);
        
        if (queriedAudits.size() > 1) {
            // Verify they are in descending order by timestamp
            for (int i = 0; i < queriedAudits.size() - 1; i++) {
                LocalDateTime current = queriedAudits.get(i).getAuditTimestamp();
                LocalDateTime next = queriedAudits.get(i + 1).getAuditTimestamp();
                
                assertTrue(
                    current.isAfter(next) || current.isEqual(next),
                    "Recent audits should be in descending timestamp order"
                );
            }
        }
    }

    @When("I submit {int} concurrent payments of {double} USD from {string} to {string}")
    public void iSubmitConcurrentPaymentsOfUSDFromTo(int count, double amount, String fromAccount, String toAccount) {
        allTransactionIds.clear();
        
        for (int i = 0; i < count; i++) {
            PaymentRequest request = new PaymentRequest();
            request.setFromAccount(fromAccount);
            request.setToAccount(toAccount);
            request.setAmount(BigDecimal.valueOf(amount));
            request.setCurrency("USD");
            request.setPaymentType(PaymentType.DOMESTIC_PAYMENT);
            request.setDescription("Concurrent payment " + i);
            
            ResponseEntity<PaymentResponse> response = restTemplate.postForEntity(
                "/api/payments",
                request,
                PaymentResponse.class
            );
            
            if (response.getBody() != null) {
                allTransactionIds.add(response.getBody().getTransactionId());
            }
        }
    }

    @Then("all {int} payments should be completed successfully")
    public void allPaymentsShouldBeCompletedSuccessfully(int count) {
        assertEquals(count, allTransactionIds.size(), 
            "Should have " + count + " transaction IDs");
    }

    @And("audit records should exist for all {int} payments")
    public void auditRecordsShouldExistForAllPayments(int count) {
        assertEquals(count, allTransactionIds.size());
        
        for (String txnId : allTransactionIds) {
            List<PaymentAudit> auditTrail = auditRepository.findByTransactionId(txnId);
            assertFalse(auditTrail.isEmpty(), 
                "Audit records should exist for transaction: " + txnId);
        }
    }

    @And("each payment should have complete audit trail")
    public void eachPaymentShouldHaveCompleteAuditTrail() {
        for (String txnId : allTransactionIds) {
            List<PaymentAudit> auditTrail = auditRepository.findByTransactionId(txnId);
            
            // Each successful payment should have at least PAYMENT_CREATED and PAYMENT_COMPLETED
            assertTrue(auditTrail.size() >= 2, 
                "Each payment should have at least 2 audit records");
            
            boolean hasCreated = auditTrail.stream()
                .anyMatch(a -> "PAYMENT_CREATED".equals(a.getAction()));
            boolean hasCompleted = auditTrail.stream()
                .anyMatch(a -> "PAYMENT_COMPLETED".equals(a.getAction()));
            
            assertTrue(hasCreated, "Audit trail should have PAYMENT_CREATED");
            assertTrue(hasCompleted, "Audit trail should have PAYMENT_COMPLETED");
        }
    }

    @When("I submit a payment of {double} USD from {string} to {string}")
    public void iSubmitAPaymentOfUSDFromTo(double amount, String fromAccount, String toAccount) {
        PaymentRequest request = new PaymentRequest();
        request.setFromAccount(fromAccount);
        request.setToAccount(toAccount);
        request.setAmount(BigDecimal.valueOf(amount));
        request.setCurrency("USD");
        request.setPaymentType(PaymentType.DOMESTIC_PAYMENT);
        request.setDescription("BDD test payment");
        
        lastPaymentResponse = restTemplate.postForEntity("/api/payments", request, PaymentResponse.class);
        
        if (lastPaymentResponse.getBody() != null) {
            lastTransactionId = lastPaymentResponse.getBody().getTransactionId();
            allTransactionIds.add(lastTransactionId);
        }
    }
}
