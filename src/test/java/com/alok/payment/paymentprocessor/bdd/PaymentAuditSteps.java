/**
 * Generated by GitHub Copilot Agent
 * Issue: #generate-tests-payment-audit-logging
 * Date: 2025-12-15
 */
package com.alok.payment.paymentprocessor.bdd;

import com.alok.payment.paymentprocessor.dto.FraudCheckResponse;
import com.alok.payment.paymentprocessor.integration.AbstractIntegrationTest;
import com.alok.payment.paymentprocessor.model.Payment;
import com.alok.payment.paymentprocessor.model.PaymentAudit;
import com.alok.payment.paymentprocessor.model.PaymentStatus;
import com.alok.payment.paymentprocessor.model.PaymentType;
import com.alok.payment.paymentprocessor.repository.PaymentAuditRepository;
import com.alok.payment.paymentprocessor.service.PaymentAuditService;
import io.cucumber.java.Before;
import io.cucumber.java.en.And;
import io.cucumber.java.en.Given;
import io.cucumber.java.en.Then;
import io.cucumber.java.en.When;
import org.springframework.beans.factory.annotation.Autowired;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;

public class PaymentAuditSteps extends AbstractIntegrationTest {

    @Autowired
    private PaymentAuditService paymentAuditService;

    @Autowired
    private PaymentAuditRepository auditRepository;

    private Payment currentPayment;
    private FraudCheckResponse currentFraudResponse;
    private PaymentAudit currentAudit;
    private List<PaymentAudit> retrievedAudits;
    private Optional<PaymentAudit> retrievedAudit;
    private Double calculatedValue;
    private Exception thrownException;
    private boolean accountValidationsPass;
    private boolean sufficientBalance;
    private LocalDateTime processingStartTime;
    private Map<String, PaymentAudit> auditCache;

    @Before
    public void setup() {
        auditCache = new HashMap<>();
        currentPayment = null;
        currentFraudResponse = null;
        currentAudit = null;
        retrievedAudits = null;
        retrievedAudit = null;
        calculatedValue = null;
        thrownException = null;
        accountValidationsPass = true;
        sufficientBalance = true;
        processingStartTime = LocalDateTime.now().minusSeconds(5);
    }

    @Given("the audit repository is clean")
    public void theAuditRepositoryIsClean() {
        auditRepository.deleteAll();
    }

    @Given("a valid payment transaction {string} from {string} to {string} for {double} USD")
    public void aValidPaymentTransaction(String transactionId, String fromAccount, String toAccount, double amount) {
        currentPayment = createPayment(transactionId, fromAccount, toAccount, new BigDecimal(String.valueOf(amount)));
        currentPayment.setStatus(PaymentStatus.COMPLETED);
        accountValidationsPass = true;
        sufficientBalance = true;
    }

    @Given("a payment transaction {string} from {string} to {string} for {double} USD")
    public void aPaymentTransaction(String transactionId, String fromAccount, String toAccount, double amount) {
        currentPayment = createPayment(transactionId, fromAccount, toAccount, new BigDecimal(String.valueOf(amount)));
    }

    @Given("the fraud check passed with risk score {double}")
    public void theFraudCheckPassedWithRiskScore(double riskScore) {
        currentFraudResponse = new FraudCheckResponse();
        currentFraudResponse.setFraudulent(false);
        currentFraudResponse.setRiskScore(riskScore);
        currentFraudResponse.setReason("Low risk");
    }

    @Given("the fraud check failed with risk score {double}")
    public void theFraudCheckFailedWithRiskScore(double riskScore) {
        currentFraudResponse = new FraudCheckResponse();
        currentFraudResponse.setFraudulent(true);
        currentFraudResponse.setRiskScore(riskScore);
        currentFraudResponse.setReason("High risk transaction");
    }

    @Given("all account validations passed")
    public void allAccountValidationsPassed() {
        accountValidationsPass = true;
        sufficientBalance = true;
    }

    @Given("the payment status is {string}")
    public void thePaymentStatusIs(String status) {
        currentPayment.setStatus(PaymentStatus.valueOf(status));
    }

    @Given("the payment failed due to insufficient balance")
    public void thePaymentFailedDueToInsufficientBalance() {
        currentPayment.setStatus(PaymentStatus.INSUFFICIENT_BALANCE);
        currentPayment.setFailureReason("Insufficient balance");
        sufficientBalance = false;
    }

    @Given("multiple payment audits exist in the system")
    public void multiplePaymentAuditsExistInTheSystem() {
        Payment payment1 = createPayment("TXN-AUDIT-001", "ACC001", "ACC002", new BigDecimal("1000.00"));
        Payment payment2 = createPayment("TXN-AUDIT-002", "ACC002", "ACC003", new BigDecimal("2000.00"));
        Payment payment3 = createPayment("TXN-AUDIT-003", "ACC003", "ACC004", new BigDecimal("3000.00"));

        FraudCheckResponse fraudResponse = createFraudResponse(false, 0.2);

        auditCache.put("TXN-AUDIT-001", paymentAuditService.auditPayment(payment1, fraudResponse, true, true, true, processingStartTime));
        auditCache.put("TXN-AUDIT-002", paymentAuditService.auditPayment(payment2, fraudResponse, true, true, true, processingStartTime));
        auditCache.put("TXN-AUDIT-003", paymentAuditService.auditPayment(payment3, fraudResponse, true, true, true, processingStartTime));
    }

    @Given("payment audits exist for account {string}")
    public void paymentAuditsExistForAccount(String account) {
        Payment payment1 = createPayment("TXN-ACC-001", account, "ACC002", new BigDecimal("1000.00"));
        Payment payment2 = createPayment("TXN-ACC-002", account, "ACC003", new BigDecimal("2000.00"));
        Payment payment3 = createPayment("TXN-ACC-003", "ACC004", account, new BigDecimal("3000.00"));

        FraudCheckResponse fraudResponse = createFraudResponse(false, 0.2);

        paymentAuditService.auditPayment(payment1, fraudResponse, true, true, true, processingStartTime);
        paymentAuditService.auditPayment(payment2, fraudResponse, true, true, true, processingStartTime);
        paymentAuditService.auditPayment(payment3, fraudResponse, true, true, true, processingStartTime);
    }

    @Given("payment audits exist with different statuses")
    public void paymentAuditsExistWithDifferentStatuses() {
        Payment payment1 = createPayment("TXN-STATUS-001", "ACC001", "ACC002", new BigDecimal("1000.00"));
        payment1.setStatus(PaymentStatus.COMPLETED);

        Payment payment2 = createPayment("TXN-STATUS-002", "ACC002", "ACC003", new BigDecimal("2000.00"));
        payment2.setStatus(PaymentStatus.COMPLETED);

        Payment payment3 = createPayment("TXN-STATUS-003", "ACC003", "ACC004", new BigDecimal("3000.00"));
        payment3.setStatus(PaymentStatus.FRAUD_CHECK_FAILED);

        paymentAuditService.auditPayment(payment1, createFraudResponse(false, 0.2), true, true, true, processingStartTime);
        paymentAuditService.auditPayment(payment2, createFraudResponse(false, 0.3), true, true, true, processingStartTime);
        paymentAuditService.auditPayment(payment3, createFraudResponse(true, 0.9), true, true, false, processingStartTime);
    }

    @Given("some payment audits with fraud detected")
    public void somePaymentAuditsWithFraudDetected() {
        Payment payment1 = createPayment("TXN-FRAUD-001", "ACC001", "ACC002", new BigDecimal("1000.00"));
        payment1.setStatus(PaymentStatus.COMPLETED);

        Payment payment2 = createPayment("TXN-FRAUD-002", "ACC002", "ACC003", new BigDecimal("5000.00"));
        payment2.setStatus(PaymentStatus.FRAUD_CHECK_FAILED);

        Payment payment3 = createPayment("TXN-FRAUD-003", "ACC003", "ACC004", new BigDecimal("10000.00"));
        payment3.setStatus(PaymentStatus.FRAUD_CHECK_FAILED);

        paymentAuditService.auditPayment(payment1, createFraudResponse(false, 0.2), true, true, true, processingStartTime);
        paymentAuditService.auditPayment(payment2, createFraudResponse(true, 0.9), true, true, false, processingStartTime);
        paymentAuditService.auditPayment(payment3, createFraudResponse(true, 0.95), true, true, false, processingStartTime);
    }

    @Given("payment audits exist from the last {int} days")
    public void paymentAuditsExistFromTheLastDays(int days) {
        LocalDateTime now = LocalDateTime.now();

        Payment payment1 = createPayment("TXN-DATE-001", "ACC001", "ACC002", new BigDecimal("1000.00"));
        Payment payment2 = createPayment("TXN-DATE-002", "ACC002", "ACC003", new BigDecimal("2000.00"));
        Payment payment3 = createPayment("TXN-DATE-003", "ACC003", "ACC004", new BigDecimal("3000.00"));

        FraudCheckResponse fraudResponse = createFraudResponse(false, 0.2);

        PaymentAudit audit1 = paymentAuditService.auditPayment(payment1, fraudResponse, true, true, true, processingStartTime);
        PaymentAudit audit2 = paymentAuditService.auditPayment(payment2, fraudResponse, true, true, true, processingStartTime);
        PaymentAudit audit3 = paymentAuditService.auditPayment(payment3, fraudResponse, true, true, true, processingStartTime);

        audit1.setAuditedAt(now.minusDays(25));
        audit2.setAuditedAt(now.minusDays(5));
        audit3.setAuditedAt(now.minusDays(2));

        auditRepository.save(audit1);
        auditRepository.save(audit2);
        auditRepository.save(audit3);
    }

    @Given("multiple completed payment audits with processing times")
    public void multipleCompletedPaymentAuditsWithProcessingTimes() {
        Payment payment1 = createPayment("TXN-TIME-001", "ACC001", "ACC002", new BigDecimal("1000.00"));
        payment1.setStatus(PaymentStatus.COMPLETED);

        Payment payment2 = createPayment("TXN-TIME-002", "ACC002", "ACC003", new BigDecimal("2000.00"));
        payment2.setStatus(PaymentStatus.COMPLETED);

        FraudCheckResponse fraudResponse = createFraudResponse(false, 0.2);

        paymentAuditService.auditPayment(payment1, fraudResponse, true, true, true, LocalDateTime.now().minusSeconds(2));
        paymentAuditService.auditPayment(payment2, fraudResponse, true, true, true, LocalDateTime.now().minusSeconds(4));
    }

    @Given("payment audits with mixed fraud results")
    public void paymentAuditsWithMixedFraudResults() {
        Payment payment1 = createPayment("TXN-RATE-001", "ACC001", "ACC002", new BigDecimal("1000.00"));
        payment1.setStatus(PaymentStatus.COMPLETED);

        Payment payment2 = createPayment("TXN-RATE-002", "ACC002", "ACC003", new BigDecimal("2000.00"));
        payment2.setStatus(PaymentStatus.FRAUD_CHECK_FAILED);

        Payment payment3 = createPayment("TXN-RATE-003", "ACC003", "ACC004", new BigDecimal("3000.00"));
        payment3.setStatus(PaymentStatus.COMPLETED);

        Payment payment4 = createPayment("TXN-RATE-004", "ACC004", "ACC001", new BigDecimal("4000.00"));
        payment4.setStatus(PaymentStatus.FRAUD_CHECK_FAILED);

        paymentAuditService.auditPayment(payment1, createFraudResponse(false, 0.2), true, true, true, processingStartTime);
        paymentAuditService.auditPayment(payment2, createFraudResponse(true, 0.9), true, true, false, processingStartTime);
        paymentAuditService.auditPayment(payment3, createFraudResponse(false, 0.1), true, true, true, processingStartTime);
        paymentAuditService.auditPayment(payment4, createFraudResponse(true, 0.95), true, true, false, processingStartTime);
    }

    @Given("a payment transaction {string} with all details")
    public void aPaymentTransactionWithAllDetails(String transactionId) {
        currentPayment = createPayment(transactionId, "ACC-DETAIL-001", "ACC-DETAIL-002", new BigDecimal("5000.00"));
        currentPayment.setStatus(PaymentStatus.COMPLETED);
        currentPayment.setDescription("Detailed payment transaction");
        currentFraudResponse = createFraudResponse(false, 0.15);
    }

    @Given("a payment of type {string} from {string} to {string} for {double} USD")
    public void aPaymentOfTypeFromToFor(String paymentType, String fromAccount, String toAccount, double amount) {
        currentPayment = createPayment(null, fromAccount, toAccount, new BigDecimal(String.valueOf(amount)));
        currentPayment.setPaymentType(PaymentType.valueOf(paymentType));
        currentPayment.setStatus(PaymentStatus.COMPLETED);
    }

    @Given("the payment has transaction ID {string}")
    public void thePaymentHasTransactionID(String transactionId) {
        currentPayment.setTransactionId(transactionId);
    }

    @Given("a payment with null transaction ID")
    public void aPaymentWithNullTransactionID() {
        currentPayment = createPayment(null, "ACC001", "ACC002", new BigDecimal("1000.00"));
        currentPayment.setTransactionId(null);
    }

    @When("the payment is audited")
    public void thePaymentIsAudited() {
        try {
            currentAudit = paymentAuditService.auditPayment(
                currentPayment,
                currentFraudResponse,
                accountValidationsPass,
                accountValidationsPass,
                sufficientBalance,
                processingStartTime
            );
        } catch (Exception e) {
            thrownException = e;
        }
    }

    @When("the failed payment is audited")
    public void theFailedPaymentIsAudited() {
        try {
            currentAudit = paymentAuditService.auditFailedPayment(
                currentPayment,
                accountValidationsPass,
                accountValidationsPass,
                processingStartTime
            );
        } catch (Exception e) {
            thrownException = e;
        }
    }

    @When("I retrieve the audit for transaction {string}")
    public void iRetrieveTheAuditForTransaction(String transactionId) {
        retrievedAudit = paymentAuditService.getAuditByTransactionId(transactionId);
    }

    @When("I retrieve all audits for account {string}")
    public void iRetrieveAllAuditsForAccount(String account) {
        retrievedAudits = paymentAuditService.getAuditsByAccount(account);
    }

    @When("I retrieve all audits with status {string}")
    public void iRetrieveAllAuditsWithStatus(String status) {
        retrievedAudits = paymentAuditService.getAuditsByStatus(PaymentStatus.valueOf(status));
    }

    @When("I retrieve all fraudulent payment audits")
    public void iRetrieveAllFraudulentPaymentAudits() {
        retrievedAudits = paymentAuditService.getFraudulentPaymentAudits();
    }

    @When("I retrieve audits from the last {int} days")
    public void iRetrieveAuditsFromTheLastDays(int days) {
        LocalDateTime endDate = LocalDateTime.now();
        LocalDateTime startDate = endDate.minusDays(days);
        retrievedAudits = paymentAuditService.getAuditsByDateRange(startDate, endDate);
    }

    @When("I calculate the average processing time")
    public void iCalculateTheAverageProcessingTime() {
        calculatedValue = paymentAuditService.calculateAverageProcessingTime();
    }

    @When("I calculate the fraud detection rate")
    public void iCalculateTheFraudDetectionRate() {
        calculatedValue = paymentAuditService.getFraudDetectionRate();
    }

    @When("the payment is audited with all fields populated")
    public void thePaymentIsAuditedWithAllFieldsPopulated() {
        currentAudit = paymentAuditService.auditPayment(
            currentPayment,
            currentFraudResponse,
            true,
            true,
            true,
            processingStartTime
        );
    }

    @When("I attempt to audit the payment")
    public void iAttemptToAuditThePayment() {
        try {
            currentAudit = paymentAuditService.auditPayment(
                currentPayment,
                currentFraudResponse,
                accountValidationsPass,
                accountValidationsPass,
                sufficientBalance,
                processingStartTime
            );
        } catch (Exception e) {
            thrownException = e;
        }
    }

    @When("I attempt to retrieve an audit with null transaction ID")
    public void iAttemptToRetrieveAnAuditWithNullTransactionID() {
        try {
            retrievedAudit = paymentAuditService.getAuditByTransactionId(null);
        } catch (Exception e) {
            thrownException = e;
        }
    }

    @When("I attempt to retrieve audits with start date after end date")
    public void iAttemptToRetrieveAuditsWithStartDateAfterEndDate() {
        try {
            LocalDateTime startDate = LocalDateTime.now();
            LocalDateTime endDate = LocalDateTime.now().minusDays(7);
            retrievedAudits = paymentAuditService.getAuditsByDateRange(startDate, endDate);
        } catch (Exception e) {
            thrownException = e;
        }
    }

    @Then("an audit record should be created for transaction {string}")
    public void anAuditRecordShouldBeCreatedForTransaction(String transactionId) {
        assertNotNull(currentAudit);
        assertEquals(transactionId, currentAudit.getTransactionId());
    }

    @Then("the audit should show fraud check passed as true")
    public void theAuditShouldShowFraudCheckPassedAsTrue() {
        assertTrue(currentAudit.getFraudCheckPassed());
    }

    @Then("the audit should show fraud check passed as false")
    public void theAuditShouldShowFraudCheckPassedAsFalse() {
        assertFalse(currentAudit.getFraudCheckPassed());
    }

    @Then("the audit should show final status as {string}")
    public void theAuditShouldShowFinalStatusAs(String status) {
        assertEquals(PaymentStatus.valueOf(status), currentAudit.getFinalStatus());
    }

    @Then("the audit should contain processing time")
    public void theAuditShouldContainProcessingTime() {
        assertNotNull(currentAudit.getProcessingTimeMs());
        assertTrue(currentAudit.getProcessingTimeMs() > 0);
    }

    @Then("the audit should contain fraud reason {string}")
    public void theAuditShouldContainFraudReason(String reason) {
        assertEquals(reason, currentAudit.getFraudReason());
    }

    @Then("the audit should show sufficient balance as false")
    public void theAuditShouldShowSufficientBalanceAsFalse() {
        assertFalse(currentAudit.getSufficientBalance());
    }

    @Then("the audit should be found")
    public void theAuditShouldBeFound() {
        assertTrue(retrievedAudit.isPresent());
    }

    @Then("the audit transaction ID should be {string}")
    public void theAuditTransactionIDShouldBe(String transactionId) {
        assertTrue(retrievedAudit.isPresent());
        assertEquals(transactionId, retrievedAudit.get().getTransactionId());
    }

    @Then("I should receive at least {int} audit record")
    public void iShouldReceiveAtLeastAuditRecord(int count) {
        assertNotNull(retrievedAudits);
        assertTrue(retrievedAudits.size() >= count);
    }

    @Then("all audits should involve account {string} as sender or receiver")
    public void allAuditsShouldInvolveAccountAsSenderOrReceiver(String account) {
        assertTrue(retrievedAudits.stream().allMatch(a -> 
            a.getFromAccount().equals(account) || a.getToAccount().equals(account)
        ));
    }

    @Then("I should receive only audits with status {string}")
    public void iShouldReceiveOnlyAuditsWithStatus(String status) {
        assertTrue(retrievedAudits.stream().allMatch(a -> 
            a.getFinalStatus() == PaymentStatus.valueOf(status)
        ));
    }

    @Then("I should receive only audits where fraud check failed")
    public void iShouldReceiveOnlyAuditsWhereFraudCheckFailed() {
        assertTrue(retrievedAudits.stream().allMatch(a -> 
            a.getFraudCheckPassed() != null && !a.getFraudCheckPassed()
        ));
    }

    @Then("I should receive only recent audits within the date range")
    public void iShouldReceiveOnlyRecentAuditsWithinTheDateRange() {
        assertNotNull(retrievedAudits);
        assertTrue(retrievedAudits.size() > 0);
    }

    @Then("I should receive a valid average processing time in milliseconds")
    public void iShouldReceiveAValidAverageProcessingTimeInMilliseconds() {
        assertNotNull(calculatedValue);
        assertTrue(calculatedValue > 0);
    }

    @Then("I should receive a fraud rate percentage")
    public void iShouldReceiveAFraudRatePercentage() {
        assertNotNull(calculatedValue);
        assertTrue(calculatedValue >= 0 && calculatedValue <= 100);
    }

    @Then("the audit record should contain transaction details")
    public void theAuditRecordShouldContainTransactionDetails() {
        assertNotNull(currentAudit.getTransactionId());
        assertNotNull(currentAudit.getAmount());
        assertNotNull(currentAudit.getCurrency());
    }

    @Then("the audit record should contain account information")
    public void theAuditRecordShouldContainAccountInformation() {
        assertNotNull(currentAudit.getFromAccount());
        assertNotNull(currentAudit.getToAccount());
    }

    @Then("the audit record should contain fraud check details")
    public void theAuditRecordShouldContainFraudCheckDetails() {
        assertNotNull(currentAudit.getFraudCheckPassed());
        assertNotNull(currentAudit.getFraudRiskScore());
    }

    @Then("the audit record should contain processing metrics")
    public void theAuditRecordShouldContainProcessingMetrics() {
        assertNotNull(currentAudit.getProcessingTimeMs());
        assertNotNull(currentAudit.getCompletedAt());
    }

    @Then("the audit record should contain validation results")
    public void theAuditRecordShouldContainValidationResults() {
        assertNotNull(currentAudit.getSourceAccountValid());
        assertNotNull(currentAudit.getDestinationAccountValid());
        assertNotNull(currentAudit.getSufficientBalance());
    }

    @Then("the audit should show payment type as {string}")
    public void theAuditShouldShowPaymentTypeAs(String paymentType) {
        assertEquals(PaymentType.valueOf(paymentType), currentAudit.getPaymentType());
    }

    @Then("an IllegalArgumentException should be thrown")
    public void anIllegalArgumentExceptionShouldBeThrown() {
        assertNotNull(thrownException);
        assertTrue(thrownException instanceof IllegalArgumentException);
    }

    @And("no audit record should be created")
    public void noAuditRecordShouldBeCreated() {
        assertNull(currentAudit);
    }

    private Payment createPayment(String transactionId, String fromAccount, String toAccount, BigDecimal amount) {
        Payment payment = new Payment();
        payment.setTransactionId(transactionId);
        payment.setFromAccount(fromAccount);
        payment.setToAccount(toAccount);
        payment.setAmount(amount);
        payment.setCurrency("USD");
        payment.setPaymentType(PaymentType.DOMESTIC_TRANSFER);
        payment.setDescription("Test payment");
        payment.setStatus(PaymentStatus.PENDING);
        return payment;
    }

    private FraudCheckResponse createFraudResponse(boolean fraudulent, double riskScore) {
        FraudCheckResponse response = new FraudCheckResponse();
        response.setFraudulent(fraudulent);
        response.setRiskScore(riskScore);
        response.setReason(fraudulent ? "High risk transaction" : "Low risk");
        return response;
    }
}
