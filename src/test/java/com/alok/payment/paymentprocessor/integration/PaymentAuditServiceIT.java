/**
 * Generated by GitHub Copilot Agent
 * Issue: #generate-tests-payment-audit-logging
 * Date: 2025-12-15
 */
package com.alok.payment.paymentprocessor.integration;

import com.alok.payment.paymentprocessor.dto.FraudCheckResponse;
import com.alok.payment.paymentprocessor.model.Payment;
import com.alok.payment.paymentprocessor.model.PaymentAudit;
import com.alok.payment.paymentprocessor.model.PaymentStatus;
import com.alok.payment.paymentprocessor.model.PaymentType;
import com.alok.payment.paymentprocessor.repository.PaymentAuditRepository;
import com.alok.payment.paymentprocessor.service.PaymentAuditService;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

import static org.junit.jupiter.api.Assertions.*;

@DisplayName("PaymentAuditService Integration Tests")
class PaymentAuditServiceIT extends AbstractIntegrationTest {

    @Autowired
    private PaymentAuditService paymentAuditService;

    @Autowired
    private PaymentAuditRepository auditRepository;

    @BeforeEach
    void setUp() {
        auditRepository.deleteAll();
    }

    @Test
    @DisplayName("Should create and retrieve audit record end-to-end")
    void testFullAuditWorkflow() {
        Payment payment = createSamplePayment("TXN-001");
        FraudCheckResponse fraudResponse = createFraudResponse(false, 0.2);
        LocalDateTime startTime = LocalDateTime.now().minusSeconds(5);

        PaymentAudit audit = paymentAuditService.auditPayment(
            payment,
            fraudResponse,
            true,
            true,
            true,
            startTime
        );

        assertNotNull(audit.getId());
        assertEquals("TXN-001", audit.getTransactionId());

        Optional<PaymentAudit> retrieved = paymentAuditService.getAuditByTransactionId("TXN-001");
        
        assertTrue(retrieved.isPresent());
        assertEquals(audit.getId(), retrieved.get().getId());
        assertEquals("TXN-001", retrieved.get().getTransactionId());
    }

    @Test
    @DisplayName("Should persist audit with fraud detection")
    void testAuditWithFraudDetection() {
        Payment payment = createSamplePayment("TXN-002");
        payment.setStatus(PaymentStatus.FRAUD_CHECK_FAILED);
        payment.setFailureReason("High risk transaction");
        
        FraudCheckResponse fraudResponse = createFraudResponse(true, 0.95);
        fraudResponse.setReason("High risk transaction");
        
        LocalDateTime startTime = LocalDateTime.now().minusSeconds(3);

        PaymentAudit audit = paymentAuditService.auditPayment(
            payment,
            fraudResponse,
            true,
            true,
            false,
            startTime
        );

        assertNotNull(audit.getId());
        
        Optional<PaymentAudit> retrieved = auditRepository.findByTransactionId("TXN-002");
        assertTrue(retrieved.isPresent());
        assertFalse(retrieved.get().getFraudCheckPassed());
        assertEquals("High risk transaction", retrieved.get().getFraudReason());
        assertEquals(PaymentStatus.FRAUD_CHECK_FAILED, retrieved.get().getFinalStatus());
    }

    @Test
    @DisplayName("Should persist failed payment audit")
    void testFailedPaymentAudit() {
        Payment payment = createSamplePayment("TXN-003");
        payment.setStatus(PaymentStatus.INSUFFICIENT_BALANCE);
        payment.setFailureReason("Insufficient balance");
        
        LocalDateTime startTime = LocalDateTime.now().minusSeconds(2);

        PaymentAudit audit = paymentAuditService.auditFailedPayment(
            payment,
            true,
            true,
            startTime
        );

        assertNotNull(audit.getId());
        
        Optional<PaymentAudit> retrieved = auditRepository.findByTransactionId("TXN-003");
        assertTrue(retrieved.isPresent());
        assertEquals(PaymentStatus.INSUFFICIENT_BALANCE, retrieved.get().getFinalStatus());
        assertFalse(retrieved.get().getSufficientBalance());
    }

    @Test
    @DisplayName("Should retrieve audits by account")
    void testGetAuditsByAccount() {
        Payment payment1 = createSamplePayment("TXN-004");
        payment1.setFromAccount("ACC001");
        payment1.setToAccount("ACC002");
        
        Payment payment2 = createSamplePayment("TXN-005");
        payment2.setFromAccount("ACC001");
        payment2.setToAccount("ACC003");
        
        Payment payment3 = createSamplePayment("TXN-006");
        payment3.setFromAccount("ACC002");
        payment3.setToAccount("ACC001");
        
        FraudCheckResponse fraudResponse = createFraudResponse(false, 0.2);
        LocalDateTime startTime = LocalDateTime.now().minusSeconds(5);

        paymentAuditService.auditPayment(payment1, fraudResponse, true, true, true, startTime);
        paymentAuditService.auditPayment(payment2, fraudResponse, true, true, true, startTime);
        paymentAuditService.auditPayment(payment3, fraudResponse, true, true, true, startTime);

        List<PaymentAudit> audits = paymentAuditService.getAuditsByAccount("ACC001");

        assertEquals(3, audits.size());
    }

    @Test
    @DisplayName("Should retrieve audits by status")
    void testGetAuditsByStatus() {
        Payment payment1 = createSamplePayment("TXN-007");
        payment1.setStatus(PaymentStatus.COMPLETED);
        
        Payment payment2 = createSamplePayment("TXN-008");
        payment2.setStatus(PaymentStatus.COMPLETED);
        
        Payment payment3 = createSamplePayment("TXN-009");
        payment3.setStatus(PaymentStatus.FRAUD_CHECK_FAILED);
        
        FraudCheckResponse fraudResponse = createFraudResponse(false, 0.2);
        LocalDateTime startTime = LocalDateTime.now().minusSeconds(5);

        paymentAuditService.auditPayment(payment1, fraudResponse, true, true, true, startTime);
        paymentAuditService.auditPayment(payment2, fraudResponse, true, true, true, startTime);
        paymentAuditService.auditPayment(payment3, createFraudResponse(true, 0.9), true, true, false, startTime);

        List<PaymentAudit> completedAudits = paymentAuditService.getAuditsByStatus(PaymentStatus.COMPLETED);

        assertEquals(2, completedAudits.size());
        assertTrue(completedAudits.stream().allMatch(a -> a.getFinalStatus() == PaymentStatus.COMPLETED));
    }

    @Test
    @DisplayName("Should retrieve fraudulent payment audits")
    void testGetFraudulentPayments() {
        Payment payment1 = createSamplePayment("TXN-010");
        payment1.setStatus(PaymentStatus.COMPLETED);
        
        Payment payment2 = createSamplePayment("TXN-011");
        payment2.setStatus(PaymentStatus.FRAUD_CHECK_FAILED);
        
        LocalDateTime startTime = LocalDateTime.now().minusSeconds(5);

        paymentAuditService.auditPayment(payment1, createFraudResponse(false, 0.2), true, true, true, startTime);
        paymentAuditService.auditPayment(payment2, createFraudResponse(true, 0.9), true, true, false, startTime);

        List<PaymentAudit> fraudulentAudits = paymentAuditService.getFraudulentPaymentAudits();

        assertEquals(1, fraudulentAudits.size());
        assertFalse(fraudulentAudits.get(0).getFraudCheckPassed());
    }

    @Test
    @DisplayName("Should retrieve audits by date range")
    void testGetAuditsByDateRange() {
        Payment payment1 = createSamplePayment("TXN-012");
        Payment payment2 = createSamplePayment("TXN-013");
        
        FraudCheckResponse fraudResponse = createFraudResponse(false, 0.2);
        LocalDateTime startTime = LocalDateTime.now().minusSeconds(5);

        PaymentAudit audit1 = paymentAuditService.auditPayment(payment1, fraudResponse, true, true, true, startTime);
        PaymentAudit audit2 = paymentAuditService.auditPayment(payment2, fraudResponse, true, true, true, startTime);

        // Update audit dates
        audit1.setAuditedAt(LocalDateTime.now().minusDays(10));
        audit2.setAuditedAt(LocalDateTime.now().minusDays(2));
        auditRepository.save(audit1);
        auditRepository.save(audit2);

        List<PaymentAudit> audits = paymentAuditService.getAuditsByDateRange(
            LocalDateTime.now().minusDays(5),
            LocalDateTime.now()
        );

        assertEquals(1, audits.size());
        assertEquals("TXN-013", audits.get(0).getTransactionId());
    }

    @Test
    @DisplayName("Should calculate average processing time")
    void testCalculateAverageProcessingTime() {
        Payment payment1 = createSamplePayment("TXN-014");
        payment1.setStatus(PaymentStatus.COMPLETED);
        
        Payment payment2 = createSamplePayment("TXN-015");
        payment2.setStatus(PaymentStatus.COMPLETED);
        
        FraudCheckResponse fraudResponse = createFraudResponse(false, 0.2);

        paymentAuditService.auditPayment(payment1, fraudResponse, true, true, true, LocalDateTime.now().minusSeconds(2));
        paymentAuditService.auditPayment(payment2, fraudResponse, true, true, true, LocalDateTime.now().minusSeconds(4));

        Double avgTime = paymentAuditService.calculateAverageProcessingTime();

        assertNotNull(avgTime);
        assertTrue(avgTime > 0);
    }

    @Test
    @DisplayName("Should calculate fraud detection rate")
    void testGetFraudDetectionRate() {
        Payment payment1 = createSamplePayment("TXN-016");
        payment1.setStatus(PaymentStatus.COMPLETED);
        
        Payment payment2 = createSamplePayment("TXN-017");
        payment2.setStatus(PaymentStatus.FRAUD_CHECK_FAILED);
        
        Payment payment3 = createSamplePayment("TXN-018");
        payment3.setStatus(PaymentStatus.COMPLETED);
        
        Payment payment4 = createSamplePayment("TXN-019");
        payment4.setStatus(PaymentStatus.FRAUD_CHECK_FAILED);
        
        LocalDateTime startTime = LocalDateTime.now().minusSeconds(5);

        paymentAuditService.auditPayment(payment1, createFraudResponse(false, 0.2), true, true, true, startTime);
        paymentAuditService.auditPayment(payment2, createFraudResponse(true, 0.9), true, true, false, startTime);
        paymentAuditService.auditPayment(payment3, createFraudResponse(false, 0.1), true, true, true, startTime);
        paymentAuditService.auditPayment(payment4, createFraudResponse(true, 0.95), true, true, false, startTime);

        Double fraudRate = paymentAuditService.getFraudDetectionRate();

        assertNotNull(fraudRate);
        assertEquals(50.0, fraudRate, 0.01);
    }

    @Test
    @DisplayName("Should handle concurrent audit creation")
    void testConcurrentAuditCreation() throws InterruptedException {
        int threadCount = 10;
        ExecutorService executorService = Executors.newFixedThreadPool(threadCount);
        CountDownLatch latch = new CountDownLatch(threadCount);

        for (int i = 0; i < threadCount; i++) {
            final int index = i;
            executorService.submit(() -> {
                try {
                    Payment payment = createSamplePayment("TXN-CONCURRENT-" + index);
                    FraudCheckResponse fraudResponse = createFraudResponse(false, 0.2);
                    
                    paymentAuditService.auditPayment(
                        payment,
                        fraudResponse,
                        true,
                        true,
                        true,
                        LocalDateTime.now().minusSeconds(5)
                    );
                } finally {
                    latch.countDown();
                }
            });
        }

        assertTrue(latch.await(30, TimeUnit.SECONDS));
        executorService.shutdown();

        long count = auditRepository.count();
        assertEquals(threadCount, count);
    }

    @Test
    @DisplayName("Should maintain data integrity for audit records")
    void testDataIntegrity() {
        Payment payment = createSamplePayment("TXN-INTEGRITY");
        payment.setDescription("Test payment for data integrity");
        payment.setFromAccount("ACC-INTEGRITY-001");
        payment.setToAccount("ACC-INTEGRITY-002");
        payment.setAmount(new BigDecimal("12345.67"));
        payment.setCurrency("EUR");
        payment.setPaymentType(PaymentType.INTERBANK_TRANSFER);
        payment.setStatus(PaymentStatus.COMPLETED);
        
        FraudCheckResponse fraudResponse = createFraudResponse(false, 0.15);
        fraudResponse.setReason("Very low risk");
        
        LocalDateTime startTime = LocalDateTime.now().minusSeconds(7);

        PaymentAudit audit = paymentAuditService.auditPayment(
            payment,
            fraudResponse,
            true,
            true,
            true,
            startTime
        );

        Optional<PaymentAudit> retrieved = auditRepository.findByTransactionId("TXN-INTEGRITY");
        
        assertTrue(retrieved.isPresent());
        PaymentAudit found = retrieved.get();
        
        assertEquals("TXN-INTEGRITY", found.getTransactionId());
        assertEquals("ACC-INTEGRITY-001", found.getFromAccount());
        assertEquals("ACC-INTEGRITY-002", found.getToAccount());
        assertEquals(0, new BigDecimal("12345.67").compareTo(found.getAmount()));
        assertEquals("EUR", found.getCurrency());
        assertEquals(PaymentType.INTERBANK_TRANSFER, found.getPaymentType());
        assertEquals("Test payment for data integrity", found.getDescription());
        assertTrue(found.getFraudCheckPassed());
        assertEquals("Very low risk", found.getFraudReason());
        assertEquals("0.15", found.getFraudRiskScore());
        assertEquals(PaymentStatus.COMPLETED, found.getFinalStatus());
        assertTrue(found.getSourceAccountValid());
        assertTrue(found.getDestinationAccountValid());
        assertTrue(found.getSufficientBalance());
        assertNotNull(found.getProcessingTimeMs());
        assertTrue(found.getProcessingTimeMs() >= 7000);
    }

    private Payment createSamplePayment(String transactionId) {
        Payment payment = new Payment();
        payment.setTransactionId(transactionId);
        payment.setFromAccount("ACC001");
        payment.setToAccount("ACC002");
        payment.setAmount(new BigDecimal("1000.00"));
        payment.setCurrency("USD");
        payment.setPaymentType(PaymentType.DOMESTIC_TRANSFER);
        payment.setStatus(PaymentStatus.COMPLETED);
        payment.setDescription("Test payment");
        return payment;
    }

    private FraudCheckResponse createFraudResponse(boolean fraudulent, double riskScore) {
        FraudCheckResponse response = new FraudCheckResponse();
        response.setFraudulent(fraudulent);
        response.setRiskScore(riskScore);
        response.setReason(fraudulent ? "High risk" : "Low risk");
        return response;
    }
}
