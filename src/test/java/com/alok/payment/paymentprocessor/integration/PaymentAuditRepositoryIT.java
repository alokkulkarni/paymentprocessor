/**
 * Generated by GitHub Copilot Agent
 * Issue: #generate-tests-payment-audit-logging
 * Date: 2025-12-15
 * DO NOT EDIT: This test was auto-generated. Review and modify as needed.
 */
package com.alok.payment.paymentprocessor.integration;

import com.alok.payment.paymentprocessor.model.PaymentAudit;
import com.alok.payment.paymentprocessor.model.PaymentStatus;
import com.alok.payment.paymentprocessor.model.PaymentType;
import com.alok.payment.paymentprocessor.repository.PaymentAuditRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.data.jdbc.DataJdbcTest;
import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase;
import org.springframework.test.context.DynamicPropertyRegistry;
import org.springframework.test.context.DynamicPropertySource;
import org.testcontainers.containers.PostgreSQLContainer;
import org.testcontainers.utility.DockerImageName;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;

@DataJdbcTest
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
@DisplayName("PaymentAuditRepository Integration Tests")
class PaymentAuditRepositoryIT {

    protected static final PostgreSQLContainer<?> postgres;

    static {
        postgres = new PostgreSQLContainer<>(DockerImageName.parse("ghcr.io/alokkulkarni/testcontainers-registry/testcontainers/postgres:16-alpine").asCompatibleSubstituteFor("postgres"))
                .withDatabaseName("paymentprocessor")
                .withUsername("test")
                .withPassword("test")
                .withInitScript("init.sql")
                .withReuse(true);
        postgres.start();
    }

    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", postgres::getJdbcUrl);
        registry.add("spring.datasource.username", postgres::getUsername);
        registry.add("spring.datasource.password", postgres::getPassword);
        registry.add("spring.sql.init.mode", () -> "never");
    }

    @Autowired
    private PaymentAuditRepository auditRepository;

    @BeforeEach
    void setUp() {
        auditRepository.deleteAll();
    }

    @Test
    @DisplayName("Should save and retrieve payment audit")
    void testSaveAndRetrieveAudit() {
        PaymentAudit audit = createSampleAudit("TXN-001", "ACC001", "ACC002");
        
        PaymentAudit saved = auditRepository.save(audit);

        assertNotNull(saved.getId());
        assertEquals("TXN-001", saved.getTransactionId());
        assertEquals("ACC001", saved.getFromAccount());
        assertEquals("ACC002", saved.getToAccount());
    }

    @Test
    @DisplayName("Should find audit by transaction ID")
    void testFindByTransactionId() {
        PaymentAudit audit = createSampleAudit("TXN-001", "ACC001", "ACC002");
        auditRepository.save(audit);

        Optional<PaymentAudit> found = auditRepository.findByTransactionId("TXN-001");

        assertTrue(found.isPresent());
        assertEquals("TXN-001", found.get().getTransactionId());
        assertEquals("ACC001", found.get().getFromAccount());
    }

    @Test
    @DisplayName("Should return empty when transaction ID not found")
    void testFindByTransactionIdNotFound() {
        Optional<PaymentAudit> found = auditRepository.findByTransactionId("INVALID");

        assertFalse(found.isPresent());
    }

    @Test
    @DisplayName("Should find audits by from account")
    void testFindByFromAccount() {
        PaymentAudit audit1 = createSampleAudit("TXN-001", "ACC001", "ACC002");
        PaymentAudit audit2 = createSampleAudit("TXN-002", "ACC001", "ACC003");
        PaymentAudit audit3 = createSampleAudit("TXN-003", "ACC002", "ACC003");
        
        auditRepository.save(audit1);
        auditRepository.save(audit2);
        auditRepository.save(audit3);

        List<PaymentAudit> found = auditRepository.findByFromAccount("ACC001");

        assertEquals(2, found.size());
        assertTrue(found.stream().allMatch(a -> a.getFromAccount().equals("ACC001")));
    }

    @Test
    @DisplayName("Should find audits by to account")
    void testFindByToAccount() {
        PaymentAudit audit1 = createSampleAudit("TXN-001", "ACC001", "ACC002");
        PaymentAudit audit2 = createSampleAudit("TXN-002", "ACC003", "ACC002");
        PaymentAudit audit3 = createSampleAudit("TXN-003", "ACC002", "ACC003");
        
        auditRepository.save(audit1);
        auditRepository.save(audit2);
        auditRepository.save(audit3);

        List<PaymentAudit> found = auditRepository.findByToAccount("ACC002");

        assertEquals(2, found.size());
        assertTrue(found.stream().allMatch(a -> a.getToAccount().equals("ACC002")));
    }

    @Test
    @DisplayName("Should find audits by final status")
    void testFindByFinalStatus() {
        PaymentAudit audit1 = createSampleAudit("TXN-001", "ACC001", "ACC002");
        audit1.setFinalStatus(PaymentStatus.COMPLETED);
        
        PaymentAudit audit2 = createSampleAudit("TXN-002", "ACC001", "ACC003");
        audit2.setFinalStatus(PaymentStatus.COMPLETED);
        
        PaymentAudit audit3 = createSampleAudit("TXN-003", "ACC002", "ACC003");
        audit3.setFinalStatus(PaymentStatus.FRAUD_CHECK_FAILED);
        
        auditRepository.save(audit1);
        auditRepository.save(audit2);
        auditRepository.save(audit3);

        List<PaymentAudit> found = auditRepository.findByFinalStatus(PaymentStatus.COMPLETED);

        assertEquals(2, found.size());
        assertTrue(found.stream().allMatch(a -> a.getFinalStatus() == PaymentStatus.COMPLETED));
    }

    @Test
    @DisplayName("Should find audits by fraud check passed status")
    void testFindByFraudCheckPassed() {
        PaymentAudit audit1 = createSampleAudit("TXN-001", "ACC001", "ACC002");
        audit1.setFraudCheckPassed(true);
        
        PaymentAudit audit2 = createSampleAudit("TXN-002", "ACC001", "ACC003");
        audit2.setFraudCheckPassed(false);
        
        PaymentAudit audit3 = createSampleAudit("TXN-003", "ACC002", "ACC003");
        audit3.setFraudCheckPassed(false);
        
        auditRepository.save(audit1);
        auditRepository.save(audit2);
        auditRepository.save(audit3);

        List<PaymentAudit> fraudulentAudits = auditRepository.findByFraudCheckPassed(false);

        assertEquals(2, fraudulentAudits.size());
        assertTrue(fraudulentAudits.stream().allMatch(a -> !a.getFraudCheckPassed()));
    }

    @Test
    @DisplayName("Should find audits by date range")
    void testFindByAuditedAtBetween() {
        LocalDateTime now = LocalDateTime.now();
        
        PaymentAudit audit1 = createSampleAudit("TXN-001", "ACC001", "ACC002");
        audit1.setAuditedAt(now.minusDays(10));
        
        PaymentAudit audit2 = createSampleAudit("TXN-002", "ACC001", "ACC003");
        audit2.setAuditedAt(now.minusDays(5));
        
        PaymentAudit audit3 = createSampleAudit("TXN-003", "ACC002", "ACC003");
        audit3.setAuditedAt(now.minusDays(1));
        
        auditRepository.save(audit1);
        auditRepository.save(audit2);
        auditRepository.save(audit3);

        List<PaymentAudit> found = auditRepository.findByAuditedAtBetween(
            now.minusDays(7), 
            now
        );

        assertEquals(2, found.size());
        assertTrue(found.stream().anyMatch(a -> a.getTransactionId().equals("TXN-002")));
        assertTrue(found.stream().anyMatch(a -> a.getTransactionId().equals("TXN-003")));
    }

    @Test
    @DisplayName("Should persist all audit fields correctly")
    void testPersistAllFields() {
        LocalDateTime now = LocalDateTime.now();
        
        PaymentAudit audit = new PaymentAudit(
            "TXN-001",
            "ACC001",
            "ACC002",
            new BigDecimal("1000.00"),
            "USD",
            PaymentType.DOMESTIC_TRANSFER
        );
        
        audit.setDescription("Test payment");
        audit.setPaymentInitiatedAt(now.minusSeconds(10));
        audit.setFraudCheckPassed(true);
        audit.setFraudReason("Low risk");
        audit.setFraudRiskScore("0.2");
        audit.setFraudCheckAt(now.minusSeconds(8));
        audit.setFinalStatus(PaymentStatus.COMPLETED);
        audit.setFailureReason(null);
        audit.setProcessingTimeMs(5000L);
        audit.setCompletedAt(now.minusSeconds(5));
        audit.setSourceAccountValid(true);
        audit.setDestinationAccountValid(true);
        audit.setSufficientBalance(true);

        PaymentAudit saved = auditRepository.save(audit);
        auditRepository.findById(saved.getId()).ifPresent(found -> {
            assertEquals("TXN-001", found.getTransactionId());
            assertEquals("ACC001", found.getFromAccount());
            assertEquals("ACC002", found.getToAccount());
            assertEquals(0, new BigDecimal("1000.00").compareTo(found.getAmount()));
            assertEquals("USD", found.getCurrency());
            assertEquals(PaymentType.DOMESTIC_TRANSFER, found.getPaymentType());
            assertEquals("Test payment", found.getDescription());
            assertTrue(found.getFraudCheckPassed());
            assertEquals("Low risk", found.getFraudReason());
            assertEquals("0.2", found.getFraudRiskScore());
            assertEquals(PaymentStatus.COMPLETED, found.getFinalStatus());
            assertEquals(5000L, found.getProcessingTimeMs());
            assertTrue(found.getSourceAccountValid());
            assertTrue(found.getDestinationAccountValid());
            assertTrue(found.getSufficientBalance());
        });
    }

    @Test
    @DisplayName("Should handle multiple audits for same transaction")
    void testMultipleAuditsPerTransaction() {
        // This should not happen in practice (transaction IDs should be unique for audits),
        // but testing repository behavior when it does happen
        PaymentAudit audit1 = createSampleAudit("TXN-001", "ACC001", "ACC002");
        auditRepository.save(audit1);
        
        // Verify first audit is found
        Optional<PaymentAudit> found = auditRepository.findByTransactionId("TXN-001");
        assertTrue(found.isPresent());
        
        // Save another audit with same transaction ID
        PaymentAudit audit2 = createSampleAudit("TXN-001", "ACC001", "ACC002");
        auditRepository.save(audit2);

        // When multiple records exist for same transaction ID, 
        // findByTransactionId will throw IncorrectResultSizeDataAccessException
        assertThrows(org.springframework.dao.IncorrectResultSizeDataAccessException.class, () -> {
            auditRepository.findByTransactionId("TXN-001");
        });
    }

    @Test
    @DisplayName("Should delete audit")
    void testDeleteAudit() {
        PaymentAudit audit = createSampleAudit("TXN-001", "ACC001", "ACC002");
        PaymentAudit saved = auditRepository.save(audit);
        
        assertNotNull(saved.getId());

        auditRepository.deleteById(saved.getId());

        Optional<PaymentAudit> found = auditRepository.findById(saved.getId());
        assertFalse(found.isPresent());
    }

    @Test
    @DisplayName("Should count all audits")
    void testCountAudits() {
        auditRepository.save(createSampleAudit("TXN-001", "ACC001", "ACC002"));
        auditRepository.save(createSampleAudit("TXN-002", "ACC001", "ACC003"));
        auditRepository.save(createSampleAudit("TXN-003", "ACC002", "ACC003"));

        long count = auditRepository.count();

        assertEquals(3, count);
    }

    private PaymentAudit createSampleAudit(String transactionId, String fromAccount, String toAccount) {
        PaymentAudit audit = new PaymentAudit(
            transactionId,
            fromAccount,
            toAccount,
            new BigDecimal("1000.00"),
            "USD",
            PaymentType.DOMESTIC_TRANSFER
        );
        audit.setFinalStatus(PaymentStatus.COMPLETED);
        audit.setFraudCheckPassed(true);
        audit.setSourceAccountValid(true);
        audit.setDestinationAccountValid(true);
        audit.setSufficientBalance(true);
        audit.setProcessingTimeMs(1000L);
        return audit;
    }
}
